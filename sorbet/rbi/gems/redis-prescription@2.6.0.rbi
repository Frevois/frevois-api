# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis-prescription` gem.
# Please instead update this file by running `bin/tapioca gem redis-prescription`.


# Lua script executor for redis.
#
# Instead of executing script with `EVAL` everytime - loads script once
# and then runs it with `EVALSHA`.
#
# @example Usage
#
#   redis  = Redis.new
#   script = RedisPrescription.new("return ARGV[1] + ARGV[2]")
#   script.call(redis, argv: [2, 2]) # => 4
#
# source://redis-prescription//lib/redis_prescription/errors.rb#3
class RedisPrescription
  # @param source [#to_s] Lua script
  # @return [RedisPrescription] a new instance of RedisPrescription
  #
  # source://redis-prescription//lib/redis_prescription.rb#36
  def initialize(source); end

  # Executes script and return result of execution.
  #
  # @param redis [Redis, RedisClient]
  # @param keys [Array] keys to pass to the script
  # @param argv [Array] arguments to pass to the script
  # @raise [TypeError] if given redis client is not supported
  # @raise [ScriptError] if script execution failed
  # @return depends on the script
  #
  # source://redis-prescription//lib/redis_prescription.rb#48
  def call(redis, keys: T.unsafe(nil), argv: T.unsafe(nil)); end

  # Lua script SHA1 digest.
  #
  # @return [String]
  #
  # source://redis-prescription//lib/redis_prescription.rb#33
  def digest; end

  # Lua script source.
  #
  # @return [String]
  #
  # source://redis-prescription//lib/redis_prescription.rb#29
  def source; end

  private

  # source://redis-prescription//lib/redis_prescription.rb#56
  def evalsha_with_fallback(adapter, redis, keys, argv); end
end

# @api internal
#
# source://redis-prescription//lib/redis_prescription/adapters/redis.rb#6
module RedisPrescription::Adapters
  class << self
    # @api internal
    # @raise [TypeError]
    #
    # source://redis-prescription//lib/redis_prescription/adapters.rb#11
    def [](redis); end
  end
end

# redis-rb adapter
#
# source://redis-prescription//lib/redis_prescription/adapters/redis.rb#8
module RedisPrescription::Adapters::Redis
  class << self
    # @return [Boolean]
    #
    # source://redis-prescription//lib/redis_prescription/adapters/redis.rb#10
    def adapts?(redis); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis.rb#14
    def eval(redis, script, keys, argv); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis.rb#20
    def evalsha(redis, digest, keys, argv); end
  end
end

# redis-client adapter
#
# source://redis-prescription//lib/redis_prescription/adapters/redis_client.rb#8
module RedisPrescription::Adapters::RedisClient
  class << self
    # @return [Boolean]
    #
    # source://redis-prescription//lib/redis_prescription/adapters/redis_client.rb#10
    def adapts?(redis); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis_client.rb#17
    def eval(redis, script, keys, argv); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis_client.rb#23
    def evalsha(redis, digest, keys, argv); end
  end
end

# redis-namespace adapter
#
# source://redis-prescription//lib/redis_prescription/adapters/redis_namespace.rb#8
module RedisPrescription::Adapters::RedisNamespace
  class << self
    # @return [Boolean]
    #
    # source://redis-prescription//lib/redis_prescription/adapters/redis_namespace.rb#10
    def adapts?(redis); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis_namespace.rb#14
    def eval(redis, script, keys, argv); end

    # source://redis-prescription//lib/redis_prescription/adapters/redis_namespace.rb#20
    def evalsha(redis, digest, keys, argv); end
  end
end

# Redis command error wrapper, `#cause` will be `Redis::CommandError` or
# `RedisClient::CommandError`.
#
# source://redis-prescription//lib/redis_prescription/errors.rb#9
class RedisPrescription::CommandError < ::RedisPrescription::Error; end

# source://redis-prescription//lib/redis_prescription.rb#24
RedisPrescription::EMPTY_LIST = T.let(T.unsafe(nil), Array)

# Top-level error class for all RedisPrescription errors
#
# source://redis-prescription//lib/redis_prescription/errors.rb#5
class RedisPrescription::Error < ::StandardError; end

# Redis error fired when script ID is unkown.
#
# source://redis-prescription//lib/redis_prescription.rb#21
RedisPrescription::NOSCRIPT = T.let(T.unsafe(nil), String)

# Lua script eval/evalsha failure
#
# source://redis-prescription//lib/redis_prescription/errors.rb#12
class RedisPrescription::ScriptError < ::RedisPrescription::Error
  # @param message [String]
  # @param source [#to_s]
  # @return [ScriptError] a new instance of ScriptError
  #
  # source://redis-prescription//lib/redis_prescription/errors.rb#52
  def initialize(message, source); end

  # Line of code where error was encountered
  #
  # @return [Integer?]
  #
  # source://redis-prescription//lib/redis_prescription/errors.rb#48
  def loc; end

  # Lua script source
  #
  # @return [String]
  #
  # source://redis-prescription//lib/redis_prescription/errors.rb#43
  def source; end

  private

  # source://redis-prescription//lib/redis_prescription/errors.rb#65
  def excerpt(source, loc); end

  # source://redis-prescription//lib/redis_prescription/errors.rb#79
  def excerpt_lines(source, loc); end
end

# source://redis-prescription//lib/redis_prescription/errors.rb#14
RedisPrescription::ScriptError::LUA_ERROR_MESSAGE = T.let(T.unsafe(nil), Regexp)

# Gem version.
#
# source://redis-prescription//lib/redis_prescription/version.rb#5
RedisPrescription::VERSION = T.let(T.unsafe(nil), String)

# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_storage_validations` gem.
# Please instead update this file by running `bin/tapioca gem active_storage_validations`.


# source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#3
module ActiveStorageValidations; end

# ActiveStorageValidations::ASVActiveStorageable
#
# Validator helper methods to make our code more explicit.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#7
module ActiveStorageValidations::ASVActiveStorageable
  extend ::ActiveSupport::Concern

  private

  # Retrieve either an `ActiveStorage::Attached::One` or an
  # `ActiveStorage::Attached::Many` instance depending on attribute definition
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#14
  def attached_files(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#18
  def attachments_present?(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#22
  def no_attachments?(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#26
  def will_have_attachments_after_save?(record, attribute); end
end

# ActiveStorageValidations::ASVAnalyzable
#
# Validator methods for choosing the right analyzer depending on the file
# media type and available third-party analyzers.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#8
module ActiveStorageValidations::ASVAnalyzable
  extend ::ActiveSupport::Concern

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#68
  def audio_analyzer_for(attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#26
  def blob_has_asv_metadata?(blob, metadata_keys); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#76
  def content_type_analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#72
  def fallback_analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#32
  def generate_metadata_for(attachable, metadata_keys); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#49
  def image_analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#58
  def image_processor; end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#40
  def metadata_analyzer_for(attachable); end

  # Retrieve the ASV metadata from the blob.
  # If the blob has not been analyzed by our gem yet, the gem will analyze the
  # attachable with the corresponding analyzer and set the metadata in the
  # blob.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#19
  def metadata_for(blob, attachable, metadata_keys); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#64
  def video_analyzer_for(attachable); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#11
ActiveStorageValidations::ASVAnalyzable::DEFAULT_IMAGE_PROCESSOR = T.let(T.unsafe(nil), Symbol)

# ActiveStorageValidations::ASVAttachable
#
# Validator methods for analyzing attachable.
#
# An attachable is a file representation such as ActiveStorage::Blob,
# ActionDispatch::Http::UploadedFile, Rack::Test::UploadedFile, Hash, String,
# File or Pathname
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#11
module ActiveStorageValidations::ASVAttachable
  extend ::ActiveSupport::Concern

  private

  # Retrieve the declared content_type from attachable without potential mime
  # type parameters (e.g. 'application/x-rar-compressed;version=5')
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#77
  def attachable_content_type(attachable); end

  # Retrieve the content_type from attachable using the same logic as Rails
  # ActiveStorage::Blob::Identifiable#identify_content_type
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#89
  def attachable_content_type_rails_like(attachable); end

  # Retrieve the declared filename from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#153
  def attachable_filename(attachable); end

  # Retrieve the io from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#105
  def attachable_io(attachable, max_byte_size: T.unsafe(nil)); end

  # Retrieve the media type of the attachable, which is the first part of the
  # content type (or mime type).
  # Possible values are: application/audio/example/font/image/model/text/video
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#100
  def attachable_media_type(attachable); end

  # Retrieve an array-like of attachables and blobs. Unlike its name suggests,
  # getting attachables from attachment_changes is not getting the changed
  # attachables but all attachables from the `has_many_attached` relation.
  # For the `has_one_attached` relation, it only yields the new attachable,
  # but if we are validating previously attached file, we need to use the blob
  # See #attach at: https://github.com/rails/rails/blob/main/activestorage/lib/active_storage/attached/many.rb
  #
  # Some file could be passed several times, we just need to perform the
  # analysis once on the file, therefore the use of #uniq.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#34
  def attachables_and_blobs(record, attribute); end

  # Remove the potential mime type parameters from the content_type (e.g.
  # 'application/x-rar-compressed;version=5')
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#83
  def content_type_without_parameters(content_type); end

  # Retrieve the full declared content_type from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#53
  def full_attachable_content_type(attachable); end

  # Retrieve the content_type from the file name only
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#200
  def marcel_content_type_from_filename(attachable); end

  # Raise the same Rails error for not-implemented file representations.
  #
  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#176
  def raise_rails_like_error(attachable); end

  # Rewind the io attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#133
  def rewind_attachable_io(attachable); end

  # Check if the current Rails version supports ActiveStorage::Blob#download_chunk
  #
  # https://github.com/rails/rails/blob/7-0-stable/activestorage/CHANGELOG.md#rails-700alpha1-september-15-2021
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#195
  def supports_blob_download_chunk?; end

  # Check if the current Rails version supports File or Pathname attachment
  #
  # https://github.com/rails/rails/blob/7-1-stable/activestorage/CHANGELOG.md#rails-710rc1-september-27-2023
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#187
  def supports_file_attachment?; end

  # Check if the current Rails version supports File or Pathname attachment
  #
  # https://github.com/rails/rails/blob/7-1-stable/activestorage/CHANGELOG.md#rails-710rc1-september-27-2023
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#187
  def supports_pathname_attachment?; end

  # Loop through the newly submitted attachables to validate them. Using
  # attachables is the only way to get the attached file io that is necessary
  # to perform file analyses.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#19
  def validate_changed_files_from_metadata(record, attribute, metadata_keys); end
end

# source://active_storage_validations//lib/active_storage_validations/extensors/asv_blob_metadatable.rb#4
module ActiveStorageValidations::ASVBlobMetadatable
  extend ::ActiveSupport::Concern
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#4
module ActiveStorageValidations::ASVErrorable
  extend ::ActiveSupport::Concern

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#20
  def add_error(record, attribute, error_type, **errors_options); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#7
  def initialize_error_options(options, file = T.unsafe(nil)); end

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#30
  def get_filename(file); end
end

# ActiveStorageValidations:::ASVFFProbable
#
# Validator helper methods for analyzers using FFprobe.
#
# source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#7
module ActiveStorageValidations::ASVFFProbable
  extend ::ActiveSupport::Concern

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#53
  def audio_stream; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#45
  def ffprobe_path; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#30
  def media_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#12
  def read_media; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#57
  def streams; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/shared/asv_ff_probable.rb#49
  def video_stream; end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_loggable.rb#4
module ActiveStorageValidations::ASVLoggable
  extend ::ActiveSupport::Concern

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_loggable.rb#7
  def logger; end
end

# ActiveStorageValidations::ASVOptionable
#
# Helper method to flatten the validator options.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#7
module ActiveStorageValidations::ASVOptionable
  extend ::ActiveSupport::Concern

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#16
  def flatten_options(record, options, available_checks = T.unsafe(nil)); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#12
  def set_flat_options(record); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#4
module ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveStorageValidations::ASVSymbolizable::ClassMethods
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#0
module ActiveStorageValidations::ASVSymbolizable::ClassMethods
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#8
  def to_sym; end
end

# = Active Storage Validations \Analyzer
#
# This is an abstract base class for analyzers, which extract metadata from attachables.
# See ActiveStorageValidations::Analyzer::VideoAnalyzer for an example of a concrete subclass.
#
# Heavily (not to say 100%) inspired by Rails own ActiveStorage::Analyzer
#
# source://active_storage_validations//lib/active_storage_validations/analyzer.rb#13
class ActiveStorageValidations::Analyzer
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVLoggable

  # @return [Analyzer] a new instance of Analyzer
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#19
  def initialize(attachable); end

  # Returns the value of attribute attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#17
  def attachable; end

  # Override this method in a concrete subclass. Have it return a String content type.
  #
  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#24
  def content_type; end

  # Override this method in a concrete subclass. Have it return a Hash of metadata.
  #
  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#29
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#83
  def instrument(analyzer, &block); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#40
  def media(tempfile); end

  # Override this method in a concrete subclass. Have it return a media object.
  #
  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#79
  def media_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#65
  def media_from_tempfile_path(tempfile, file_representation); end

  # Override this method in a concrete subclass. Have it yield a media object.
  #
  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#36
  def read_media; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#22
class ActiveStorageValidations::Analyzer::AudioAnalyzer < ::ActiveStorageValidations::Analyzer
  include ::ActiveStorageValidations::ASVFFProbable

  # source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#25
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#43
  def bit_rate; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#38
  def duration; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#48
  def sample_rate; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/audio_analyzer.rb#53
  def tags; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/content_type_analyzer.rb#17
class ActiveStorageValidations::Analyzer::ContentTypeAnalyzer < ::ActiveStorageValidations::Analyzer
  # source://active_storage_validations//lib/active_storage_validations/analyzer/content_type_analyzer.rb#20
  def content_type; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/content_type_analyzer.rb#47
  def media_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/content_type_analyzer.rb#30
  def read_media; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/content_type_analyzer.rb#18
class ActiveStorageValidations::Analyzer::ContentTypeAnalyzer::FileCommandLineToolNotInstalledError < ::StandardError; end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#14
class ActiveStorageValidations::Analyzer::ImageAnalyzer < ::ActiveStorageValidations::Analyzer
  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#17
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#31
  def analyzer_supported?; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#40
  def rotated_image?(media); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#45
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#7
class ActiveStorageValidations::Analyzer::ImageAnalyzer::ImageMagick < ::ActiveStorageValidations::Analyzer::ImageAnalyzer
  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#29
  def media_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#11
  def read_media; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#35
  def rotated_image?(image); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#39
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#6
class ActiveStorageValidations::Analyzer::ImageAnalyzer::Vips < ::ActiveStorageValidations::Analyzer::ImageAnalyzer
  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#28
  def media_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#10
  def read_media; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#43
  def rotated_image?(image); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#49
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#42
ActiveStorageValidations::Analyzer::ImageAnalyzer::Vips::ROTATIONS = T.let(T.unsafe(nil), Regexp)

# source://active_storage_validations//lib/active_storage_validations/analyzer/null_analyzer.rb#13
class ActiveStorageValidations::Analyzer::NullAnalyzer < ::ActiveStorageValidations::Analyzer
  # source://active_storage_validations//lib/active_storage_validations/analyzer/null_analyzer.rb#14
  def metadata; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#26
class ActiveStorageValidations::Analyzer::VideoAnalyzer < ::ActiveStorageValidations::Analyzer
  include ::ActiveStorageValidations::ASVFFProbable

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#29
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#65
  def angle; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#92
  def audio?; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#100
  def computed_height; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#126
  def container; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#77
  def display_aspect_ratio; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#114
  def display_height_scale; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#73
  def display_matrix; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#60
  def duration; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#110
  def encoded_height; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#106
  def encoded_width; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#52
  def height; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#88
  def rotated?; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#122
  def side_data; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#118
  def tags; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#96
  def video?; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/video_analyzer.rb#44
  def width; end
end

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#11
class ActiveStorageValidations::AspectRatioValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#33
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#38
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#76
  def aspect_ratio_error_mapping; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#55
  def authorized_aspect_ratio?(record, attribute, attachable, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#136
  def authorized_aspect_ratios_from_options(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#118
  def ensure_aspect_ratio_validity; end

  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#112
  def ensure_at_least_one_validator_option; end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#128
  def invalid_aspect_ratio_message; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#50
  def is_valid?(record, attribute, attachable, metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#83
  def media_metadata_missing?(record, attribute, attachable, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#140
  def string_aspect_ratios; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#100
  def valid_landscape_aspect_ratio?(metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#96
  def valid_portrait_aspect_ratio?(metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#104
  def valid_regex_aspect_ratio?(aspect_ratio, metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#92
  def valid_square_aspect_ratio?(metadata); end
end

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#21
ActiveStorageValidations::AspectRatioValidator::ASPECT_RATIO_REGEX = T.let(T.unsafe(nil), Regexp)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#19
ActiveStorageValidations::AspectRatioValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#22
ActiveStorageValidations::AspectRatioValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#31
ActiveStorageValidations::AspectRatioValidator::METADATA_KEYS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#20
ActiveStorageValidations::AspectRatioValidator::NAMED_ASPECT_RATIOS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#30
ActiveStorageValidations::AspectRatioValidator::PRECISION = T.let(T.unsafe(nil), Integer)

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#8
class ActiveStorageValidations::AttachedValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#15
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#23
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#13
ActiveStorageValidations::AttachedValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#9
class ActiveStorageValidations::BaseComparisonValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # @return [BaseComparisonValidator] a new instance of BaseComparisonValidator
  #
  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#23
  def initialize(*args); end

  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#30
  def check_validity!; end

  private

  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#59
  def format_bound_value; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#38
  def is_valid?(value, flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#67
  def max(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#63
  def min(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#54
  def populate_error_options(errors_options, flat_options); end
end

# source://active_storage_validations//lib/active_storage_validations/base_comparison_validator.rb#15
ActiveStorageValidations::BaseComparisonValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#12
class ActiveStorageValidations::ContentTypeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#27
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#32
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#137
  def attachable_content_type_intersects_detected_content_type?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#132
  def attachable_content_type_vs_detected_content_type_mismatch?; end

  # errors_options = initialize_and_populate_error_options(options, attachable)
  #   add_error(record, attribute, ERROR_TYPES.first, **errors_options)
  #   false
  # end
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#89
  def authorized_content_type?(record, attribute, attachable); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#46
  def authorized_content_types_from_options(record); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#161
  def content_type_to_human_format(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#124
  def disable_spoofing_protection?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#128
  def enable_spoofing_protection?; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#144
  def enlarged_content_type(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#182
  def ensure_content_types_validity; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#176
  def ensure_exactly_one_validator_option; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#152
  def initialize_and_populate_error_options(options, attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#213
  def invalid_content_type?(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#190
  def invalid_content_type_option_message(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#221
  def invalid_extension?(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#204
  def invalid_option?(content_type); end

  # Check if the provided content_type is authorized and not spoofed against
  # the file io.
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#64
  def is_valid?(record, attribute, attachable, blob); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#104
  def marcel_attachable_content_type(attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#108
  def not_spoofing_content_type?(record, attribute, attachable, blob); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#148
  def parent_content_types(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#57
  def set_attachable_cached_values(blob); end
end

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#20
ActiveStorageValidations::ContentTypeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#21
ActiveStorageValidations::ContentTypeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#25
ActiveStorageValidations::ContentTypeValidator::METADATA_KEYS = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#11
class ActiveStorageValidations::DimensionValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#35
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#41
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#49
  def is_valid?(record, attribute, file, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#128
  def process_options(record); end
end

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#19
ActiveStorageValidations::DimensionValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#20
ActiveStorageValidations::DimensionValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#33
ActiveStorageValidations::DimensionValidator::METADATA_KEYS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/duration_validator.rb#6
class ActiveStorageValidations::DurationValidator < ::ActiveStorageValidations::BaseComparisonValidator
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable

  # source://active_storage_validations//lib/active_storage_validations/duration_validator.rb#19
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/duration_validator.rb#48
  def format_bound_value(value); end
end

# source://active_storage_validations//lib/active_storage_validations/duration_validator.rb#10
ActiveStorageValidations::DurationValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/duration_validator.rb#17
ActiveStorageValidations::DurationValidator::METADATA_KEYS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/engine.rb#4
class ActiveStorageValidations::Engine < ::Rails::Engine
  class << self
    private

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#15
    def __class_attr___callbacks; end

    # source://activesupport/8.0.1/lib/active_support/class_attribute.rb#17
    def __class_attr___callbacks=(new_value); end
  end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#9
class ActiveStorageValidations::LimitValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#22
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#27
  def validate_each(record, attribute, _value); end

  private

  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#67
  def ensure_arguments_validity; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#61
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#51
  def files_count_valid?(count, flat_options); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#88
  def min_higher_than_max?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#74
  def min_max_are_proc?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#83
  def min_or_max_defined_and_not_integer?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#78
  def min_or_max_is_proc_and_other_not_present?; end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#15
ActiveStorageValidations::LimitValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#16
ActiveStorageValidations::LimitValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/processable_file_validator.rb#10
class ActiveStorageValidations::ProcessableFileValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/processable_file_validator.rb#22
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/processable_file_validator.rb#30
  def is_valid?(record, attribute, attachable, metadata); end
end

# source://active_storage_validations//lib/active_storage_validations/processable_file_validator.rb#17
ActiveStorageValidations::ProcessableFileValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/processable_file_validator.rb#20
ActiveStorageValidations::ProcessableFileValidator::METADATA_KEYS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/railtie.rb#4
class ActiveStorageValidations::Railtie < ::Rails::Railtie; end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#6
class ActiveStorageValidations::SizeValidator < ::ActiveStorageValidations::BaseComparisonValidator
  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#15
  def number_to_human_size(*_arg0, **_arg1, &_arg2); end

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#17
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#38
  def format_bound_value(value); end
end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#7
ActiveStorageValidations::SizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#6
class ActiveStorageValidations::TotalSizeValidator < ::ActiveStorageValidations::BaseComparisonValidator
  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#15
  def number_to_human_size(*_arg0, **_arg1, &_arg2); end

  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#17
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#39
  def custom_check_validity!(record, attribute); end

  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#47
  def format_bound_value(value); end
end

# source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#7
ActiveStorageValidations::TotalSizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `with_advisory_lock` gem.
# Please instead update this file by running `bin/tapioca gem with_advisory_lock`.


class ActiveRecord::Base
  include ::ActiveModel::Access
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  include ::WithAdvisoryLock::Concern
  extend ::WithAdvisoryLock::Concern::ClassMethods
end

# source://with_advisory_lock//lib/with_advisory_lock/version.rb#3
module WithAdvisoryLock; end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#23
class WithAdvisoryLock::Base
  # @return [Base] a new instance of Base
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#26
  def initialize(connection, lock_name, options); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#52
  def already_locked?; end

  # Returns the value of attribute connection.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def connection; end

  # Returns the value of attribute disable_query_cache.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def disable_query_cache; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#66
  def lock_and_yield(&block); end

  # Returns the value of attribute lock_name.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def lock_name; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#50
  def lock_stack(&block); end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#42
  def lock_stack_item; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#38
  def lock_str; end

  # Returns the value of attribute shared.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def shared; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#76
  def stable_hashcode(input); end

  # Returns the value of attribute timeout_seconds.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def timeout_seconds; end

  # Returns the value of attribute transaction.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#24
  def transaction; end

  # Prevent AR from caching results improperly
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#114
  def unique_column_name; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#56
  def with_advisory_lock_if_needed(&block); end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#98
  def yield_with_lock; end

  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#86
  def yield_with_lock_and_timeout(&block); end

  class << self
    # source://with_advisory_lock//lib/with_advisory_lock/base.rb#46
    def lock_stack; end
  end
end

# source://with_advisory_lock//lib/with_advisory_lock/concern.rb#4
module WithAdvisoryLock::Concern
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::WithAdvisoryLock::Concern::ClassMethods

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#6
  def advisory_lock_exists?(*_arg0, **_arg1, &_arg2); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#6
  def with_advisory_lock(*_arg0, **_arg1, &_arg2); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#6
  def with_advisory_lock!(*_arg0, **_arg1, &_arg2); end
end

# source://with_advisory_lock//lib/with_advisory_lock/concern.rb#0
module WithAdvisoryLock::Concern::ClassMethods
  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#26
  def advisory_lock_exists?(lock_name); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#31
  def current_advisory_lock; end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#9
  def with_advisory_lock(lock_name, options = T.unsafe(nil), &block); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#14
  def with_advisory_lock!(lock_name, options = T.unsafe(nil), &block); end

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#21
  def with_advisory_lock_result(lock_name, options = T.unsafe(nil), &block); end

  private

  # source://with_advisory_lock//lib/with_advisory_lock/concern.rb#38
  def impl_class; end
end

# source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#4
class WithAdvisoryLock::DatabaseAdapterSupport
  # @return [DatabaseAdapterSupport] a new instance of DatabaseAdapterSupport
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#9
  def initialize(connection); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#14
  def mysql?; end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#18
  def postgresql?; end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/database_adapter_support.rb#22
  def sqlite?; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#19
WithAdvisoryLock::FAILED_TO_LOCK = T.let(T.unsafe(nil), WithAdvisoryLock::Result)

# source://with_advisory_lock//lib/with_advisory_lock/failed_to_acquire_lock.rb#4
class WithAdvisoryLock::FailedToAcquireLock < ::StandardError
  # @return [FailedToAcquireLock] a new instance of FailedToAcquireLock
  #
  # source://with_advisory_lock//lib/with_advisory_lock/failed_to_acquire_lock.rb#5
  def initialize(lock_name); end
end

# source://with_advisory_lock//lib/with_advisory_lock/flock.rb#6
class WithAdvisoryLock::Flock < ::WithAdvisoryLock::Base
  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#16
  def file_io; end

  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#7
  def filename; end

  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#29
  def release_lock; end

  # @raise [ArgumentError]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/flock.rb#23
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#21
class WithAdvisoryLock::LockStackItem < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute shared
  #
  # @return [Object] the current value of shared
  def shared; end

  # Sets the attribute shared
  #
  # @param value [Object] the value to set the attribute shared to.
  # @return [Object] the newly set value
  def shared=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#4
class WithAdvisoryLock::MySQL < ::WithAdvisoryLock::Base
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#17
  def execute_successful?(mysql_function); end

  # MySQL wants a string as the lock key.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#23
  def quoted_lock_str; end

  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#13
  def release_lock; end

  # See https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_get-lock
  #
  # @raise [ArgumentError]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/mysql.rb#6
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#4
class WithAdvisoryLock::PostgreSQL < ::WithAdvisoryLock::Base
  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#27
  def execute_successful?(pg_function); end

  # PostgreSQL wants 2 32bit integers as the lock key.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#36
  def lock_keys; end

  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#11
  def release_lock; end

  # See http://www.postgresql.org/docs/9.1/static/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS
  #
  # source://with_advisory_lock//lib/with_advisory_lock/postgresql.rb#6
  def try_lock; end
end

# source://with_advisory_lock//lib/with_advisory_lock/base.rb#6
class WithAdvisoryLock::Result
  # @return [Result] a new instance of Result
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#9
  def initialize(lock_was_acquired, result = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#14
  def lock_was_acquired?; end

  # Returns the value of attribute result.
  #
  # source://with_advisory_lock//lib/with_advisory_lock/base.rb#7
  def result; end
end

# source://with_advisory_lock//lib/with_advisory_lock/version.rb#4
WithAdvisoryLock::VERSION = T.let(T.unsafe(nil), Gem::Version)
